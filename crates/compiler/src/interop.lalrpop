use ast::*;
use lexer::TokenType;

use lalrpop_util::ParseError;

grammar<'input>(input: &'input str);

// // From highest to lowest precedence
// pub Expr: i32 = {
//     #[precedence(level="0")]
//     Term,

//     #[precedence(level="1")]
//     #[assoc(side="left")]
//     <l:Expr> "*" <r:Expr> => l * r,
//     <l:Expr> "/" <r:Expr> => l / r,

//     #[precedence(level="2")]
//     #[assoc(side="left")]
//     <l:Expr> "+" <r:Expr> => l + r,
//     <l:Expr> "-" <r:Expr> => l - r,
// };

// pub Term: i32 = {
//     <INT_LIT>,
//     "(" <INT_LIT> ")",
// };

// *** Macros ***

SepOptTrailing<T, C>: Vec<T> = {
    <mut v:(<T> C)*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

Block<T>: Block<'input> = {
    // Semicolon cannot be optional on last item because
    // then it creates if/then shift/reduce issue
    ":" <expr: (<Expr> ";")+> T => Block {expr}
};

// *** Top level ***

pub File: Vec<Decl<'input>> = {
    SOI <(<Decl> ";")*> EOI
};

Decl: Decl<'input> = {
    FuncDecl => Decl::Func(<>)
};

// *** Basic Non-terminals ***

Ident: Ident<'input> = {
    <start: @L> IDENT <end: @R> => {
        Ident::from_str(&input[start as usize..end as usize])
    }
};

IntLit: IntLit = {
    <start: @L> NUMBER_LIT <end: @R> =>? {
        input[start as usize..end as usize]
            .parse()
            .map(|value| IntLit { value })
            .map_err(|_| ParseError::User {
                error: "Integer literal is larger than 2^32"
            }
        )
    }
};

// *** Types ***

Type: Type<'input> = {
    Ident => Type::Simple(<>),
};

// *** Expressions ***

Expr: Expr<'input> = {
    If => Expr::If(<>),
    FuncDecl => Expr::Func(<>),
    SimpleExpr => Expr::Simple(<>),
};

SimpleExpr: SimpleExpr<'input> = {
    Ident => SimpleExpr::Ident(<>),
    IntLit => SimpleExpr::IntLit(<>),
    "(" <Expr> ")" => SimpleExpr::Expr(Box::new(<>)),
};

// *** Function ***

// Parse a list of function arg names
FuncArgIdents: Vec<Ident<'input>> = {
    // We don't want trailing comma support here
    <arg:Ident> <args: ("," <Ident>)*> => {
        let mut v = Vec::with_capacity(args.len() + 1);
        v.push(arg);
        v.extend(args);
        v
    }
};

// Parse a function arg duplicating type and default value to all args
FuncArg: Vec<FuncArg<'input>> = {
    <args: FuncArgIdents> ":" <arg_type: Type> <default_val: ("=" <SimpleExpr>)?> => {
        args.into_iter().map(|name| FuncArg {
            name,
            arg_type: arg_type.clone(),
            default_val: default_val.clone(),
        }).collect()
    }
};

FuncArgs: Vec<FuncArg<'input>> = {
    SepOptTrailing<FuncArg, ","> => <>.into_iter().flatten().collect()
};

FuncBody: FuncBody<'input> = {
    <ret_type: ("->" <Type>)?> <block: Block<"end">> => FuncBody::Block(ret_type, block),
    "->"? <SimpleExpr> => FuncBody::Expr(<>),
};

FuncDecl: FuncDecl<'input> = {
    "func" <name: Ident> "(" <args: FuncArgs> ")" <body: FuncBody> => {
        FuncDecl {
            name,
            args,
            body,
        }
    }
};

// *** If ***

IfBody: (ThenBody<'input>, Option<ElseBody<'input>>) = {
    <expr: SimpleExpr> <else_: ("else" <ElseBody>)?> => (ThenBody::Expr(expr), else_),
    <block: Block<"else">> <else_: ElseBody> => (ThenBody::Block(block), Some(else_)),
    Block<"end"> => (ThenBody::Block(<>), None),
};

ElseBody: ElseBody<'input> = {
    // Special case 'else if' to allow chaining (since not a simple expression)
    If => ElseBody::If(Box::new(<>)),
    Block<"end"> => ElseBody::Block(<>),
    SimpleExpr => ElseBody::Expr(<>),
};

pub If: If<'input> = {
    "if" <cond: SimpleExpr> "then" <if_body: IfBody> => {
        If { cond, then_body: if_body.0, else_body: if_body.1 }
    }
};

// *** Terminals ***

extern {
    type Location = u32;
    type Error = &'static str;

    enum TokenType {
        SOI => TokenType::StartOfInput,
        EOI => TokenType::EndOfInput,

        // COMMENT_TOK => TokenType::Comment,

        IDENT => TokenType::Ident,
        NUMBER_LIT => TokenType::Number,

        "(" => TokenType::LeftParen,
        ")" => TokenType::RightParen,
        ";" => TokenType::Semi,
        ":" => TokenType::Colon,
        "=" => TokenType::Equals,
        "," => TokenType::Comma,
        "->" => TokenType::RArrow,

        // MULTIPLY_TOK => TokenType::Multiply,
        // DIVIDE_TOK => TokenType::Divide,
        // PLUS_TOK => TokenType::Plus,
        // MINUS_TOK => TokenType::Minus,
        
        "func" => TokenType::Func,
        "end" => TokenType::End,
        "if" => TokenType::If,
        "then" => TokenType::Then,
        "else" => TokenType::Else,
    }
}
