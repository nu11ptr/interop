{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction and Features Interop is a simple programming language designed for general purpose programming. It does not generate native machine code, but instead compiles to other programming languages for simple FFI. Below is a quick highlight of the features Interop provides. Before we get to that, why do I think a new language is needed? In summary, desired language features don't compose between languages. What do I mean by that? I mean if language A that you like has A, B, C features/syntax/elements and language B has D, E, and F features how do you use them together? Answer: You don't, you settle. This right here is why there is so many languages. You can't just fundementally merge two languages, you create a third. (And now we have three problems instead of two... \ud83d\ude00) Enough of that, on to the language features! Feature Summary Imagine Go, Python, and Rust had a baby \ud83d\ude00 Not trying to break huge new ground, but refine existing ideas Simple language with a small feature set (Go), but that must compose well together Syntax Python-like, but not exactly No significant whitespace A safe language No null poiners, statically typed, etc. (but not as safe as Ada/Rust) Large focuse on interoperability with other languages by generating into those languages directly (Haxe/Nim) Hence the name \"Interop\" First target language will be Go Highly opinionated, not a lot of different ways to do things (Go) Slightly functional, but imperative (Rust) Most things are an expression, first class functions, sum types, pattern matching, etc. Error handling using special type of try/catch block but not really exceptions (no stack unwinding - a little like Swift) Major focus on auto-formatting There will be one \"correct\" way to format and the language will be designed for it Automatic memory management Likely using tracing garbage collection for most language targets Value types will minimize amount of garbage on some targets Parallelism must be first class Still under consideration Leaning towards async/await model","title":"Introduction and Features"},{"location":"#introduction-and-features","text":"Interop is a simple programming language designed for general purpose programming. It does not generate native machine code, but instead compiles to other programming languages for simple FFI. Below is a quick highlight of the features Interop provides. Before we get to that, why do I think a new language is needed? In summary, desired language features don't compose between languages. What do I mean by that? I mean if language A that you like has A, B, C features/syntax/elements and language B has D, E, and F features how do you use them together? Answer: You don't, you settle. This right here is why there is so many languages. You can't just fundementally merge two languages, you create a third. (And now we have three problems instead of two... \ud83d\ude00) Enough of that, on to the language features!","title":"Introduction and Features"},{"location":"#feature-summary","text":"Imagine Go, Python, and Rust had a baby \ud83d\ude00 Not trying to break huge new ground, but refine existing ideas Simple language with a small feature set (Go), but that must compose well together Syntax Python-like, but not exactly No significant whitespace A safe language No null poiners, statically typed, etc. (but not as safe as Ada/Rust) Large focuse on interoperability with other languages by generating into those languages directly (Haxe/Nim) Hence the name \"Interop\" First target language will be Go Highly opinionated, not a lot of different ways to do things (Go) Slightly functional, but imperative (Rust) Most things are an expression, first class functions, sum types, pattern matching, etc. Error handling using special type of try/catch block but not really exceptions (no stack unwinding - a little like Swift) Major focus on auto-formatting There will be one \"correct\" way to format and the language will be designed for it Automatic memory management Likely using tracing garbage collection for most language targets Value types will minimize amount of garbage on some targets Parallelism must be first class Still under consideration Leaning towards async/await model","title":"Feature Summary"},{"location":"comments/","text":"NOTE: There is no multi-line comment # This is a comment","title":"Comments"},{"location":"concepts/","text":"Simplicity The language MUST be simple . To that end, each feature the language gets must be painstakingly researched and considered to see how it fits into the language as a whole. This will not be a language with several ways to do the same thing. I think Go really made strides here in showing the value of simplicity. The benefit of this is we will not be looking to constantly add the newest thing in programming language theory, but want to keep the language small, simple, and focused. That said, we are not making a language for complete novices either (unlike Go). This must be a very expressive and productive language with few features, but that compose well together. To that end, it will have a semi-functional feel to it (more below) but ultimately be imperative. Picking up a new language in one or two days is great, but if you are immediately suffering due to lack of compositiion or expressiveness, you won't be as productive longer term. Goal : Imagine Go being on the far left and a language like Rust on the far right. We are aiming somewhat left of center. Considerably less complex than Rust, but solidly more capable than Go. Syntax TODO Safety TODO Language Interoperability TODO Highly Opinionated TODO Functional Flair TODO Error Handling TODO Auto Formatting TODO Memory Management TODO First Class Parallalism TODO","title":"Concepts"},{"location":"concepts/#simplicity","text":"The language MUST be simple . To that end, each feature the language gets must be painstakingly researched and considered to see how it fits into the language as a whole. This will not be a language with several ways to do the same thing. I think Go really made strides here in showing the value of simplicity. The benefit of this is we will not be looking to constantly add the newest thing in programming language theory, but want to keep the language small, simple, and focused. That said, we are not making a language for complete novices either (unlike Go). This must be a very expressive and productive language with few features, but that compose well together. To that end, it will have a semi-functional feel to it (more below) but ultimately be imperative. Picking up a new language in one or two days is great, but if you are immediately suffering due to lack of compositiion or expressiveness, you won't be as productive longer term. Goal : Imagine Go being on the far left and a language like Rust on the far right. We are aiming somewhat left of center. Considerably less complex than Rust, but solidly more capable than Go.","title":"Simplicity"},{"location":"concepts/#syntax","text":"TODO","title":"Syntax"},{"location":"concepts/#safety","text":"TODO","title":"Safety"},{"location":"concepts/#language-interoperability","text":"TODO","title":"Language Interoperability"},{"location":"concepts/#highly-opinionated","text":"TODO","title":"Highly Opinionated"},{"location":"concepts/#functional-flair","text":"TODO","title":"Functional Flair"},{"location":"concepts/#error-handling","text":"TODO","title":"Error Handling"},{"location":"concepts/#auto-formatting","text":"TODO","title":"Auto Formatting"},{"location":"concepts/#memory-management","text":"TODO","title":"Memory Management"},{"location":"concepts/#first-class-parallalism","text":"TODO","title":"First Class Parallalism"},{"location":"declarations/","text":"Struct (FUTURE) Basic structure/record type struct ABC: test : int test2: str end impl ABC: func new(test: int, test2: str): let self.test = test let mut self.test2 = test2 end end Enums (FUTURE) tagged union always pass by value (types inside can be ref) uses type constructures to initialize enums do not create a new scope immutable str() method returns name of enum from type constructor (ie. 'Thursday', 'Some(\"test\")') from_str() method returns an enum, if possible (only type constructors w/o args supported) # Effectively an interface + 2 structs enum Option[T]: Some(T) None end # Effectively an interface + 2 structs enum Result[T]: Ok(T) Error(str) end # Compiled efficiently to integers enum DayOfWeek: Sunday Monday Tuesday Wednesday Thursday Friday Saturday end # Compiled efficiently to integers enum Suites: Hearts = 0 Spades = 1 Diamonds = 2 Clubs = 3 end let x = Some(1) let dow: Option[DayOfWeek] = DayOfWeek.from_str(\"Thursday) # require derive annotation? impl DayOfWeek: func is_weekend() -> bool: self match: Saturday, Sunday -> true _ -> false end end end Interfaces (FUTURE) \"magic methods\"? Maybe.... interface equal: __equal__(any) -> bool end interface bool: __bool__() -> bool end interface iterator[T]: next() -> result[T] end impl equal for DayOfWeek: func __equal__(a: any) -> bool: match self: dow: DayOfWeek -> self == dow _ -> false end end end","title":"Declarations"},{"location":"declarations/#struct-future","text":"Basic structure/record type struct ABC: test : int test2: str end impl ABC: func new(test: int, test2: str): let self.test = test let mut self.test2 = test2 end end","title":"Struct (FUTURE)"},{"location":"declarations/#enums-future","text":"tagged union always pass by value (types inside can be ref) uses type constructures to initialize enums do not create a new scope immutable str() method returns name of enum from type constructor (ie. 'Thursday', 'Some(\"test\")') from_str() method returns an enum, if possible (only type constructors w/o args supported) # Effectively an interface + 2 structs enum Option[T]: Some(T) None end # Effectively an interface + 2 structs enum Result[T]: Ok(T) Error(str) end # Compiled efficiently to integers enum DayOfWeek: Sunday Monday Tuesday Wednesday Thursday Friday Saturday end # Compiled efficiently to integers enum Suites: Hearts = 0 Spades = 1 Diamonds = 2 Clubs = 3 end let x = Some(1) let dow: Option[DayOfWeek] = DayOfWeek.from_str(\"Thursday) # require derive annotation? impl DayOfWeek: func is_weekend() -> bool: self match: Saturday, Sunday -> true _ -> false end end end","title":"Enums (FUTURE)"},{"location":"declarations/#interfaces-future","text":"\"magic methods\"? Maybe.... interface equal: __equal__(any) -> bool end interface bool: __bool__() -> bool end interface iterator[T]: next() -> result[T] end impl equal for DayOfWeek: func __equal__(a: any) -> bool: match self: dow: DayOfWeek -> self == dow _ -> false end end end","title":"Interfaces (FUTURE)"},{"location":"expressions/","text":"If/Then/Else Expression FUTURE: In addition to bool expressions, if/elif will accept any type that implements the Bool interface As a safety precaution, type unit should not implement Bool to prevent assignments in if expressions # With blocks let abc = if test == \"123\" then: let abc = 1000 abc else if test == \"456\" then: let xyz = 456 xyz else: let def = 7 def end # Without blocks let abc2 = if test == \"123\" then 1000 else if test == \"456\" then 456 else 7 Function Expression Similar to function bindings, minus the binding name FUTURE: Consider a shorter/simpler one liner syntax for inline functions let abc = func (a, b: int = 1) -> str: \"test\" end test(param1 = 123, param2 = func (a, b: int = 1) -> str: \"test\" end) # FUTURE func (a, b) -> a + b # single expression only, return type derived from expression? Prefix Expressions (1) -1 not 1 # FUTURE: rhs can be any type that implements Bool interface Infix Expressions 1 + 2 1 - 2 1 * 2 1 / 2 1 mod 2 1 == 2 1 != 2 1 >= 2 1 <= 2 1 > 2 1 < 2 5 in [1, 2, 3] 5 not in [1, 2, 3] 1 and 2 # FUTURE: lhs/rhs can be any type that implements Bool interface 1 or 2 # FUTURE: lhs/rhs can be any type that implements Bool interface # Bitwise 250 ^ 32 # xor 255 & 10 # and 16 | 48 # or ~ 16 # not (prefix expr) # Call myname(1, 2, 3) myname(1, num = 2, age = 3) # Can specify args names (once you specify one, the rest must also) # FUTURE: Indexing (arrays, lists, tuples, and maps) # FUTURE: Anything that supports the right interface myname[0] # first element myname[-1] # last element, python-style myname[10:15] # slice # FUTURE: Qualified names mymod.test myobj.attr Comprehensions (POSSIBLE FUTURE) TODO: Syntax could be hard to parse (x <- for x in range(start: 1, end: 10) if x > 0) # iterator [x <- for x in range(start: 1, end: 10) if x > 0] # list {x <- for x in range(start: 1, end: 10) if x > 0} # map {|x <- for x in range(start: 1, end: 10) if x > 0|} # set Match (FUTURE) Basic pattern matching Typical bind syntax create bindings for matched types 'as' binds entire expression func abc(a Any) -> result[int]: match a: Some(x: int) -> x b: int -> b _ as y -> y # Catch all end end match abc: 1, 2 -> true _ -> false end Try/Catch (POSSIBLE FUTURE) Not exceptions Used with things that implement a special interface func abc(a, b: int) -> result[int]: func do_ret(err: error) -> error: println(err) err end # single expression version # err is default - specified for illustration let z = try some_op_that_can_fail() catch as err: do_ret(err) end end func abc(a, b: int) -> result[int]: func do_ret(err: error) -> error: println(err) err end # multi expression version let abc = try: z <- some_op_that_can_fail() # <- syntax only allowed in try block print(z) # Normal statements allowed in block too x <- some_other_op() x + z catch as err: # err is default - specified for illustration do_ret(err) end end For Works with any type that implements the Iterator[T] interface TODO: Loop labels needed??? (could be tricky with it being an expression) alternative: break break? FUTURE: Consider making this an expression break EXPR works as an early return Otherwise, last expression is returned for x in xyz: if false then break else continue end # FUTURE: What this could look like in the future??? let z = for x in xyz: if x == 100 then: break x + 23 end else: x end While Simple while block while true: if false then break else continue end # FUTURE: What this could look like in the future??? let z = while x > 0: if x == 100 then: break x + 23 end x += 1 else: x end Loop Infinite loop Effectively Sugar for 'while true' let x = loop: if false then: break 1 else: continue end end With (FUTURE) Similiar to Python 'with' Can be used with any type implementing the 'context' interface Special method called on entry and on exit from the block If decide to make expression, returns last expression let x = with mytype(123) as a: a.do_stuff() 123 end Coroutines (POSSIBLE FUTURE) if has optional expression behind it, returns it # Coroutine producing a \"lazy list\" for xyz(x: int) -> coroutine[int, ()]: for y in range(x,100): yield y * 10 end end # Coroutine for xyz() -> coroutine[(), int]: loop: let y := yield println(y) end end Async/Await TODO","title":"Expressions"},{"location":"expressions/#ifthenelse-expression","text":"FUTURE: In addition to bool expressions, if/elif will accept any type that implements the Bool interface As a safety precaution, type unit should not implement Bool to prevent assignments in if expressions # With blocks let abc = if test == \"123\" then: let abc = 1000 abc else if test == \"456\" then: let xyz = 456 xyz else: let def = 7 def end # Without blocks let abc2 = if test == \"123\" then 1000 else if test == \"456\" then 456 else 7","title":"If/Then/Else Expression"},{"location":"expressions/#function-expression","text":"Similar to function bindings, minus the binding name FUTURE: Consider a shorter/simpler one liner syntax for inline functions let abc = func (a, b: int = 1) -> str: \"test\" end test(param1 = 123, param2 = func (a, b: int = 1) -> str: \"test\" end) # FUTURE func (a, b) -> a + b # single expression only, return type derived from expression?","title":"Function Expression"},{"location":"expressions/#prefix-expressions","text":"(1) -1 not 1 # FUTURE: rhs can be any type that implements Bool interface","title":"Prefix Expressions"},{"location":"expressions/#infix-expressions","text":"1 + 2 1 - 2 1 * 2 1 / 2 1 mod 2 1 == 2 1 != 2 1 >= 2 1 <= 2 1 > 2 1 < 2 5 in [1, 2, 3] 5 not in [1, 2, 3] 1 and 2 # FUTURE: lhs/rhs can be any type that implements Bool interface 1 or 2 # FUTURE: lhs/rhs can be any type that implements Bool interface # Bitwise 250 ^ 32 # xor 255 & 10 # and 16 | 48 # or ~ 16 # not (prefix expr) # Call myname(1, 2, 3) myname(1, num = 2, age = 3) # Can specify args names (once you specify one, the rest must also) # FUTURE: Indexing (arrays, lists, tuples, and maps) # FUTURE: Anything that supports the right interface myname[0] # first element myname[-1] # last element, python-style myname[10:15] # slice # FUTURE: Qualified names mymod.test myobj.attr","title":"Infix Expressions"},{"location":"expressions/#comprehensions-possible-future","text":"TODO: Syntax could be hard to parse (x <- for x in range(start: 1, end: 10) if x > 0) # iterator [x <- for x in range(start: 1, end: 10) if x > 0] # list {x <- for x in range(start: 1, end: 10) if x > 0} # map {|x <- for x in range(start: 1, end: 10) if x > 0|} # set","title":"Comprehensions (POSSIBLE FUTURE)"},{"location":"expressions/#match-future","text":"Basic pattern matching Typical bind syntax create bindings for matched types 'as' binds entire expression func abc(a Any) -> result[int]: match a: Some(x: int) -> x b: int -> b _ as y -> y # Catch all end end match abc: 1, 2 -> true _ -> false end","title":"Match (FUTURE)"},{"location":"expressions/#trycatch-possible-future","text":"Not exceptions Used with things that implement a special interface func abc(a, b: int) -> result[int]: func do_ret(err: error) -> error: println(err) err end # single expression version # err is default - specified for illustration let z = try some_op_that_can_fail() catch as err: do_ret(err) end end func abc(a, b: int) -> result[int]: func do_ret(err: error) -> error: println(err) err end # multi expression version let abc = try: z <- some_op_that_can_fail() # <- syntax only allowed in try block print(z) # Normal statements allowed in block too x <- some_other_op() x + z catch as err: # err is default - specified for illustration do_ret(err) end end","title":"Try/Catch (POSSIBLE FUTURE)"},{"location":"expressions/#for","text":"Works with any type that implements the Iterator[T] interface TODO: Loop labels needed??? (could be tricky with it being an expression) alternative: break break? FUTURE: Consider making this an expression break EXPR works as an early return Otherwise, last expression is returned for x in xyz: if false then break else continue end # FUTURE: What this could look like in the future??? let z = for x in xyz: if x == 100 then: break x + 23 end else: x end","title":"For"},{"location":"expressions/#while","text":"Simple while block while true: if false then break else continue end # FUTURE: What this could look like in the future??? let z = while x > 0: if x == 100 then: break x + 23 end x += 1 else: x end","title":"While"},{"location":"expressions/#loop","text":"Infinite loop Effectively Sugar for 'while true' let x = loop: if false then: break 1 else: continue end end","title":"Loop"},{"location":"expressions/#with-future","text":"Similiar to Python 'with' Can be used with any type implementing the 'context' interface Special method called on entry and on exit from the block If decide to make expression, returns last expression let x = with mytype(123) as a: a.do_stuff() 123 end","title":"With (FUTURE)"},{"location":"expressions/#coroutines-possible-future","text":"if has optional expression behind it, returns it # Coroutine producing a \"lazy list\" for xyz(x: int) -> coroutine[int, ()]: for y in range(x,100): yield y * 10 end end # Coroutine for xyz() -> coroutine[(), int]: loop: let y := yield println(y) end end","title":"Coroutines (POSSIBLE FUTURE)"},{"location":"expressions/#asyncawait","text":"TODO","title":"Async/Await"},{"location":"statements/","text":"Function bindings Mandatory arg types (not inferred in any way) Arg grouping ('a' below is also of type int just like 'b') Default values (for example, '1' below A fresh copy of each default arg is used at each call site Body is made up of one or more statements or expressions Exits at either last expression or return statement func my_func(a, b: int = 1) -> str: \"test\" end Variable binding let = bind a name to an expression (immutable binding) let mut = bind a name to an expression (mutable binding) Type is optional in almost all cases (inferred from expression) FUTURE: Each binding type can be done in a block let abc = 123 + add_me() let mut def : str = \"test\" + \"ok\" let test1, test2 = 1, 2 # future - rhs is a tuple, it is unpacked into test1/test2 # POSSIBLE FUTURE let: test12345 = 123 tester : int = 456 abc = 789 end Assignments Bindings assigned by let mut can be reassigned def = 456 # def must have been bound by 'let mut' Break, Continue, Return func xyz() -> int: return 1 end let y = loop: if x then: continue else: break 1 end end","title":"Statements"},{"location":"statements/#function-bindings","text":"Mandatory arg types (not inferred in any way) Arg grouping ('a' below is also of type int just like 'b') Default values (for example, '1' below A fresh copy of each default arg is used at each call site Body is made up of one or more statements or expressions Exits at either last expression or return statement func my_func(a, b: int = 1) -> str: \"test\" end","title":"Function bindings"},{"location":"statements/#variable-binding","text":"let = bind a name to an expression (immutable binding) let mut = bind a name to an expression (mutable binding) Type is optional in almost all cases (inferred from expression) FUTURE: Each binding type can be done in a block let abc = 123 + add_me() let mut def : str = \"test\" + \"ok\" let test1, test2 = 1, 2 # future - rhs is a tuple, it is unpacked into test1/test2 # POSSIBLE FUTURE let: test12345 = 123 tester : int = 456 abc = 789 end","title":"Variable binding"},{"location":"statements/#assignments","text":"Bindings assigned by let mut can be reassigned def = 456 # def must have been bound by 'let mut'","title":"Assignments"},{"location":"statements/#break-continue-return","text":"func xyz() -> int: return 1 end let y = loop: if x then: continue else: break 1 end end","title":"Break, Continue, Return"},{"location":"types/","text":"Value Types Boolean Type name: bool Size: typically 8 bits, but depends on platform true false Integer Type name: int, uint Size: at least 31 bits (varies by platform?) 1234 1234u # future Alternate formats, not repeated for others but can be combined (FUTURE) 0x0f0f # hex 0b0101 # binary 0o0707 # octal 1_000_000 # underscores for grouping Long Integer (FUTURE) Type name: long, ulong Size: at least 63 bits (varies by platform) 1234L 1234uL Exact sized integers (FUTURE) Type name: int8, uint8, byte (alias for uint8), int16, uint16, int32, uint32, int64, uint64 Size: 8 to 64 bits (based on suffix) 1i8 1u8 1b # equiv to 1u8 1i16 1u16 1i32 1u32 1i64 1u64 FUTURE: Char - char (4 bytes - default encoding is UTF8) 'a' '\\uFFFFFFFF' # Unicode literal char '\\xFF' # hex char '\\o77' # octal char '\\b01010101' # binary char String Type name: str Stored as a byte array Immutable Ends with a null 0 for C compatibility but is not used otherwise in length calculation \"abc\" # Std set of encodings ``\"abc\"`` # future - contains any char except double backtick Unit Type name: () Effectively an empty tuple Only one value () # Future Tuple Type name: (int,int) # of types listed based on tuple arity Immutable - changing it returns a new tuple Implemented using something like an array (but passed by value) (1,) (1, 2) Reference Type Expressions Array (FUTURE) Type name: array[int] Fixed length, not resizable Mutable [|1, 2, 3|] List (FUTURE) Type name: list[int] Has capacity and length Appendable up to capacity and then auto-grows Implemented using an array Can be indexed - O(n) and sliced Python-like index operations Mutable TODO: Doesn't address length/capacity allocation [1, 2, 3] let abc = [1, 2, 3] # if all elements are same type, no need specify type let abc: list[addable] = [\"a\", 1] # if aren't all same type, list the interface they share (defaults to list[any]) Set (FUTURE) Type name: set[int] Implemented using a map (or modified map) No guaranteed iteration order Mutable TODO: Doesn't address capacity allocation {|1, 2, 3|} let abc = {|1, 2, 3|} # if all elements are same type, no need specify type let abc: set[addable] = {|\"a\", 1|} # if aren't all same type, list the interface they share (defaults to list[any]) Map (FUTURE) Type name: map[str, int] No guaranteed iteration order Mutable TODO: Doesn't address capacity allocation {1 -> 2, 3 -> 4} let abc = {1 -> 'a', 3 -> 'b'} # if all elements are same type (all keys/all values), no need specify type let abc: map[int, addable] = {1 -> \"a\", 2 -> 1} # if aren't all same type, list the interface they share (defaults to map[int, any] in this case) TODO: Missing - floating point? arbitrary length decimal? bigint?","title":"Types"},{"location":"types/#value-types","text":"","title":"Value Types"},{"location":"types/#boolean","text":"Type name: bool Size: typically 8 bits, but depends on platform true false","title":"Boolean"},{"location":"types/#integer","text":"Type name: int, uint Size: at least 31 bits (varies by platform?) 1234 1234u # future","title":"Integer"},{"location":"types/#alternate-formats-not-repeated-for-others-but-can-be-combined-future","text":"0x0f0f # hex 0b0101 # binary 0o0707 # octal 1_000_000 # underscores for grouping","title":"Alternate formats, not repeated for others but can be combined (FUTURE)"},{"location":"types/#long-integer-future","text":"Type name: long, ulong Size: at least 63 bits (varies by platform) 1234L 1234uL","title":"Long Integer (FUTURE)"},{"location":"types/#exact-sized-integers-future","text":"Type name: int8, uint8, byte (alias for uint8), int16, uint16, int32, uint32, int64, uint64 Size: 8 to 64 bits (based on suffix) 1i8 1u8 1b # equiv to 1u8 1i16 1u16 1i32 1u32 1i64 1u64 FUTURE: Char - char (4 bytes - default encoding is UTF8) 'a' '\\uFFFFFFFF' # Unicode literal char '\\xFF' # hex char '\\o77' # octal char '\\b01010101' # binary char","title":"Exact sized integers (FUTURE)"},{"location":"types/#string","text":"Type name: str Stored as a byte array Immutable Ends with a null 0 for C compatibility but is not used otherwise in length calculation \"abc\" # Std set of encodings ``\"abc\"`` # future - contains any char except double backtick","title":"String"},{"location":"types/#unit","text":"Type name: () Effectively an empty tuple Only one value () # Future","title":"Unit"},{"location":"types/#tuple","text":"Type name: (int,int) # of types listed based on tuple arity Immutable - changing it returns a new tuple Implemented using something like an array (but passed by value) (1,) (1, 2)","title":"Tuple"},{"location":"types/#reference-type-expressions","text":"","title":"Reference Type Expressions"},{"location":"types/#array-future","text":"Type name: array[int] Fixed length, not resizable Mutable [|1, 2, 3|]","title":"Array (FUTURE)"},{"location":"types/#list-future","text":"Type name: list[int] Has capacity and length Appendable up to capacity and then auto-grows Implemented using an array Can be indexed - O(n) and sliced Python-like index operations Mutable TODO: Doesn't address length/capacity allocation [1, 2, 3] let abc = [1, 2, 3] # if all elements are same type, no need specify type let abc: list[addable] = [\"a\", 1] # if aren't all same type, list the interface they share (defaults to list[any])","title":"List (FUTURE)"},{"location":"types/#set-future","text":"Type name: set[int] Implemented using a map (or modified map) No guaranteed iteration order Mutable TODO: Doesn't address capacity allocation {|1, 2, 3|} let abc = {|1, 2, 3|} # if all elements are same type, no need specify type let abc: set[addable] = {|\"a\", 1|} # if aren't all same type, list the interface they share (defaults to list[any])","title":"Set (FUTURE)"},{"location":"types/#map-future","text":"Type name: map[str, int] No guaranteed iteration order Mutable TODO: Doesn't address capacity allocation {1 -> 2, 3 -> 4} let abc = {1 -> 'a', 3 -> 'b'} # if all elements are same type (all keys/all values), no need specify type let abc: map[int, addable] = {1 -> \"a\", 2 -> 1} # if aren't all same type, list the interface they share (defaults to map[int, any] in this case) TODO: Missing - floating point? arbitrary length decimal? bigint?","title":"Map (FUTURE)"}]}